"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const yanl_1 = require("yanl");
const SourceProvider_1 = require("./SourceProvider");
const SimpleEventEmitter_1 = require("./SimpleEventEmitter");
var State;
(function (State) {
    State[State["Listening"] = 0] = "Listening";
    State[State["Stopping"] = 1] = "Stopping";
    State[State["Stopped"] = 2] = "Stopped";
})(State || (State = {}));
var Events;
(function (Events) {
    Events["Error"] = "error";
    Events["ListenStart"] = "listen-start";
    Events["ListenStop"] = "listen-stop";
    Events["StatusCleared"] = "status-cleared";
    Events["StatusUpdated"] = "status-updated";
})(Events || (Events = {}));
function assertIsDefined(value, message) {
    assert_1.default(value != null, message);
}
class NowPlayingMonitor extends SimpleEventEmitter_1.SimpleEventEmitter {
    constructor(statusPublisher) {
        super();
        this.statusPublisher = statusPublisher;
        this.isStatusDirty = false;
        this.sourceProvider = null;
        this.state = State.Stopped;
    }
    /**
     * Listens to track changes using the provided source.
     */
    listen() {
        assertIsDefined(this.sourceProvider, 'Expected source to be specified');
        // istanbul ignore if
        if (this.state === State.Listening) {
            return;
        }
        this.state = State.Listening;
        this.sourceProvider.listen();
        this.emit(Events.ListenStart);
    }
    /**
     * Stop listening to track changes using the provided source. Calling this
     * will clear the profile status if it has been already updated.
     */
    async stop() {
        assertIsDefined(this.sourceProvider, 'Expected source to be specified');
        // istanbul ignore if
        if (this.state === State.Stopped || this.state === State.Stopping) {
            return;
        }
        this.state = State.Stopping;
        this.sourceProvider.stop();
        await this.cleanUp();
        this.state = State.Stopped;
        this.emit(Events.ListenStop);
    }
    /**
     * Sets a source from which the currently playing track will be retrieved.
     */
    setSource(source) {
        let autoStartNextSource = false;
        if (this.sourceProvider) {
            autoStartNextSource = this.sourceProvider.isListening();
            this.unsetSourceProvider();
        }
        this.setSourceProvider(source, autoStartNextSource);
    }
    setSourceProvider(source, autoStart) {
        this.sourceProvider = source;
        this.sourceProvider
            .on(SourceProvider_1.SourceProvider.Events.TrackChanged, this.updateStatus.bind(this))
            .on(SourceProvider_1.SourceProvider.Events.TrackStopped, this.clearStatus.bind(this))
            .on(SourceProvider_1.SourceProvider.Events.Error, this.emitError.bind(this));
        if (autoStart) {
            this.sourceProvider.listen();
        }
    }
    unsetSourceProvider() {
        assertIsDefined(this.sourceProvider, 'Expected source to be specified');
        this.sourceProvider.stop();
        this.sourceProvider.removeAllListeners();
    }
    async updateStatus(track) {
        try {
            const status = await this.statusPublisher.set({
                emoji: ':musical_note:',
                message: `is listening to "${track.title}" by ${track.artist}`,
            });
            this.isStatusDirty = true;
            this.emit(Events.StatusUpdated, status);
        }
        catch (error) {
            this.emitError(error);
        }
    }
    async clearStatus() {
        try {
            yanl_1.logger.debug('clearing the profile status');
            await this.statusPublisher.clear();
            this.isStatusDirty = false;
            this.emit(Events.StatusCleared);
        }
        catch (error) {
            this.emitError(error);
        }
    }
    emitError(error) {
        this.emit(Events.Error, error);
    }
    async cleanUp() {
        if (this.isStatusDirty) {
            await this.clearStatus();
        }
    }
}
exports.NowPlayingMonitor = NowPlayingMonitor;
/**
 * A dictionary containing event names for a GitHubNowPlaying instance
 */
NowPlayingMonitor.Events = Events;
