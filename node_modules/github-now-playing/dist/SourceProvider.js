"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const yanl_1 = require("yanl");
const SimpleEventEmitter_1 = require("./SimpleEventEmitter");
var State;
(function (State) {
    State[State["Listening"] = 0] = "Listening";
    State[State["Stopped"] = 1] = "Stopped";
})(State || (State = {}));
var Events;
(function (Events) {
    Events["Error"] = "error";
    Events["TrackChanged"] = "track-changed";
    Events["TrackStopped"] = "track-stopped";
})(Events || (Events = {}));
class SourceProvider extends SimpleEventEmitter_1.SimpleEventEmitter {
    constructor(options) {
        super();
        this.options = options;
        this.state = State.Stopped;
        this.lastTrack = null;
    }
    isListening() {
        return this.state === State.Listening;
    }
    listen() {
        // istanbul ignore if
        if (this.isListening()) {
            return;
        }
        yanl_1.logger.debug('started listening from source');
        this.state = State.Listening;
        this.checkNowPlaying();
    }
    stop() {
        yanl_1.logger.debug('stopped listening from source');
        this.state = State.Stopped;
        clearTimeout(this.nextCheckTimeout);
    }
    getNowPlaying() {
        throw new Error(`Method \`getNowPlaying\` is not implemented in ${this.constructor.name}`);
    }
    async checkNowPlaying() {
        yanl_1.logger.debug('checking source for now playing track');
        let track = null;
        try {
            track = await this.getNowPlaying();
        }
        catch (error) {
            this.emit(Events.Error, error);
            return;
        }
        // bail out in case the source provider has been stopped while the check was pending
        if (this.state === State.Stopped) {
            return;
        }
        if (this.hasTrackChanged(track)) {
            if (track) {
                this.emit(Events.TrackChanged, track);
            }
            else {
                this.emit(Events.TrackStopped);
            }
            this.lastTrack = track;
        }
        this.nextCheckTimeout = setTimeout(() => this.checkNowPlaying(), this.options.updateFrequency);
        yanl_1.logger.debug('scheduled next source check');
    }
    hasTrackChanged(track) {
        const { lastTrack } = this;
        if (lastTrack == null || track == null) {
            return lastTrack !== track;
        }
        const keys = Object.keys(track);
        return keys.some(key => track[key] !== lastTrack[key]);
    }
}
exports.SourceProvider = SourceProvider;
SourceProvider.Events = Events;
